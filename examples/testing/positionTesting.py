import argparse
import os
import re
import Bio
from Bio import SeqIO

amplicons = []

"""
Functions
"""
def reverseStrand(seq):
    return seq[::-1]

#find an amplicon by id in the list of amplicons
def findAmplicon(seq_id):
    if(seq_id <= 0):
        return None
    for amplicon in amplicons:
        if(amplicon['id'] == seq_id):
            return amplicon
    return None

def getComplement(base):
    if base == 'A':
        return 'T'
    if base == 'T':
        return 'A'
    if base == 'C':
        return 'G'
    if base == 'G':
        return 'C'

def complementStrand(seq):
    strand = list(seq)
    i = 0
    while i < len(strand):
        strand[i] = getComplement(strand[i])
        i += 1
    return "".join(strand)

#try to align an amplicon sequence with the reference sequence and return all matching positions
def align(am_seq, ref_seq, method):
    start = 0
    foundMatches = []
    while True:                                                                 # keep searching as long as we don't have a match
        i = 0
        errors = 0
        if(start + len(am_seq) > len(ref_seq)):                                 # if the start plus the length of the amplicon would exceed the length of the ref seq
            return foundMatches                                                 # we failed
        while i < len(am_seq) and i+start < len(ref_seq) and errors < 10:       # while the search indicees are in bound and we don't exceed the error tolerance (due to mutations)
            if(seq[i+start] != am_seq[i]):                                      # if the bases don't match, it's an error
                errors += 1
            i += 1                                                              # check next bases
        if errors < 10:                                                          # if we have less than 3 errors for this, it's a successful match
            foundMatches.append({'pos':start,'src':method})
        start += 1                                                              # else, check the next position as a potential starting position
    return foundMatches

#for normal, reverse&complementary, reverse only and complementary only, try to align
#the amplicon to the ref sequence and collect all matches
#if there are no matches found, print an error
def findRealPosition(am_seq, ref_seq, pos, name):
    foundMatches = align(am_seq, ref_seq, 'normal')
    tmp_seq = reverseStrand(am_seq)
    foundMatches += align(tmp_seq, ref_seq, 'rev')
    tmp_seq = complementStrand(tmp_seq)
    foundMatches += align(tmp_seq, ref_seq, 'rev/compl')
    tmp_seq = complementStrand(am_seq)
    foundMatches += align(tmp_seq, ref_seq, 'compl')

    if(len(foundMatches) == 0):
        print("R" + str(name) + ", " + str(pos) + ", len " + str(len(am_seq)) + " could not be matched")
    else:
        for match in foundMatches:
            print("R" + str(name) + ", " + str(pos) + ", len " + str(len(am_seq)) + " should be at " + str(match['pos']) + " with " + match['src'])

    return foundMatches

"""
Main
"""
# parse input arguments
parser = argparse.ArgumentParser()
parser.add_argument('--input', action='store', help='amplicons file generated by MDAsim')
parser.add_argument('--seq', action='store', help='reference sequence')
params = parser.parse_args()

# get amplicons
with open(params.input) as f:
    lines = f.readlines()
lines = [x.strip() for x in lines]
i = 0

# parse amplicons and their header
while i < len(lines):
    header = re.split('\||\.|=', lines[i])
    header = [x.strip() for x in header]
    header = [x.replace(">", "") for x in header]
    length = int(header[2])
    name = header[0]
    name_id = int(name.replace("R",""))
    original_fragment = int(header[4])
    last_pos = int(header[6])
    ref_start_pos = int(header[8])
    strand = header[10]
    seq = lines[i+1]
    amplicons.append({'id':name_id, 'orig':original_fragment, 'refstart':ref_start_pos, 'last':last_pos, 'seq':seq, 'strand':strand})
    i+=2

# get reference sequence
for entry in SeqIO.parse(params.seq, "fasta"):                                  #read original reference sequence
    seq = entry.seq;

total_fails = 0
total = 0
boundsMinus = 0
boundsPlus = 0
success = []
fail = []

# try to align the amplicons with the reference sequence at the position that
# was noted in the header
for amplicon in amplicons:                           # for every amplicon in the list
    am_seq = amplicon['seq']
    if amplicon['strand'] == '+':
        start = amplicon['refstart']-1               # read the start position relative to the ref sequence
    else:
        start = amplicon['refstart']
        am_seq = reverseStrand(complementStrand(am_seq))

    if start < 0:                                   # if the position is smaller than 0 it's probably the reverse strand (this shouldn't happen anymore)
        print("OUT OF BOUNDS: " + str("R" + str(amplicon['id'])) + " starts at " + str(start))
        fail.append(amplicon)
    elif start > len(seq):                          # if the start is behind the length of the ref seq, something's wrong
        print("OUT OF BOUNDS: " + str("R" + str(amplicon['id'])) + " starts at " + str(start))
        fail.append(amplicon)
    elif start+len(am_seq)-1 > len(seq):            # if the end of the amplicon would be behind that of ref, something's also wrong
        print("OUT OF BOUNDS: " + str("R" + str(amplicon['id'])) + " ends at " + str(i+start+len(am_seq)-1))
        fail.append(amplicon)

    # if there's not out of bounds error, we try to align it
    else:
        fails = 0
        i = 0
        while i < len(am_seq) and i+start < len(seq):
            if(seq[i+start] != am_seq[i]):
                fails += 1
            i += 1
        if fails > 10:
            fail.append(amplicon)
        else:
            success.append(amplicon)
    total += 1

print("> SUCCESSFUL MATCHES (1st Try, position correct): " + str(len(success)) + " out of " + str(len(amplicons)))

# try to align the amplicons with faulty reference positions brute force
found_fails = 0
for f in fail:
    foundMatches = findRealPosition(f['seq'], seq, f['refstart'], f['id'])
    found_fails += len(foundMatches)

print("------RESULTS-----")

print("> SUCCESSFUL MATCHES (1st Try, position correct): " + str(len(success)) + " out of " + str(len(amplicons)))

print("> SUCCESSFUL MATCHES (2nd Try, position incorrect but alignment possible): " + str(found_fails) + " of " + str(len(amplicons)))

print("> FAILS (no alignment possible): " + str(len(fail)-found_fails) + " of " + str(len(amplicons)))
