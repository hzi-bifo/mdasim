import argparse
import os
import re
import Bio
from Bio import SeqIO

amplicons = []

"""
Functions
"""
def reverseStrand(seq):
    return seq[::-1]

#find an amplicon by id in the list of amplicons
def findAmplicon(seq_id):
    if(seq_id <= 0):
        return None
    for amplicon in amplicons:
        if(amplicon['id'] == seq_id):
            return amplicon
    return None

def getComplement(base):
    if base == 'A':
        return 'T'
    if base == 'T':
        return 'A'
    if base == 'C':
        return 'G'
    if base == 'G':
        return 'C'

def complementStrand(seq):
    strand = list(seq)
    i = 0
    while i < len(strand):
        strand[i] = getComplement(strand[i])
        i += 1
    return "".join(strand)

def match(am_seq, ref_seq, start):
    fails = 0
    i = 0
    failed = False
    preceeding_errors = 0;
    while i < len(am_seq) and i+start < len(ref_seq):
        if(ref_seq[i+start] != am_seq[i]):
            preceeding_errors += 1
            fails += 1
            if fails > len(am_seq)*0.01 or preceeding_errors > 10:
                return False
        else:
            preceeding_errors = 0
        i += 1
    return True;

#try to align an amplicon sequence with the reference sequence and return all matching positions
def align(am_seq, ref_seq, method):
    start = 0
    foundMatches = []
    while True:                                                                 # keep searching as long as we don't have a match
        #i = 0
        #errors = 0
        if(start + len(am_seq) > len(ref_seq)):                                 # if the start plus the length of the amplicon would exceed the length of the ref seq
            return foundMatches                                                 # we failed
        matches = match(am_seq, ref_seq, start)
        if matches:
            foundMatches.append({'pos':start,'src':method})
        #while i < len(am_seq) and i+start < len(ref_seq) and errors < 10:       # while the search indicees are in bound and we don't exceed the error tolerance (due to mutations)
        #    if(seq[i+start] != am_seq[i]):                                      # if the bases don't match, it's an error
        #        errors += 1
        #    i += 1                                                              # check next bases
        #if errors < 10:                                                          # if we have less than 3 errors for this, it's a successful match
        #    foundMatches.append({'pos':start,'src':method})
        start += 1                                                              # else, check the next position as a potential starting position
    return foundMatches

#for normal, reverse&complementary, reverse only and complementary only, try to align
#the amplicon to the ref sequence and collect all matches
#if there are no matches found, print an error
def findRealPosition(am_seq, ref_seq, pos, name):
    foundMatches = align(am_seq, ref_seq, 'normal')
    tmp_seq = reverseStrand(am_seq)
    foundMatches += align(tmp_seq, ref_seq, 'rev')
    tmp_seq = complementStrand(tmp_seq)
    foundMatches += align(tmp_seq, ref_seq, 'rev/compl')
    tmp_seq = complementStrand(am_seq)
    foundMatches += align(tmp_seq, ref_seq, 'compl')

    if(len(foundMatches) == 0):
        print("R" + str(name) + ", " + str(pos) + ", len " + str(len(am_seq)) + " could not be matched")
    else:
        for match in foundMatches:
            print("R" + str(name) + ", " + str(pos) + ", len " + str(len(am_seq)) + " should be at " + str(match['pos']) + " with " + match['src'])

    return foundMatches

"""
Main
"""
# parse input arguments
parser = argparse.ArgumentParser()
parser.add_argument('--input', action='store', help='amplicons file generated by MDAsim')
parser.add_argument('--seq', action='store', help='reference sequence')
params = parser.parse_args()

# get amplicons
with open(params.input) as f:
    lines = f.readlines()
lines = [x.strip() for x in lines]
i = 0

# parse amplicons and their header
while i < len(lines):
    header = re.split('\||\.|=', lines[i])
    header = [x.strip() for x in header]
    header = [x.replace(">", "") for x in header]
    length = int(header[2])
    name = header[0]
    name_id = int(name.replace("R",""))
    original_fragment = int(header[4])
    last_pos = int(header[6])
    ref_start_pos = int(header[8])
    strand = header[10]
    seq = lines[i+1]
    amplicons.append({'id':name_id, 'orig':original_fragment, 'refstart':ref_start_pos, 'last':last_pos, 'seq':seq, 'strand':strand, 'offset':0})
    i+=2

# get reference sequence
for entry in SeqIO.parse(params.seq, "fasta"):                                  #read original reference sequence
    seq = entry.seq;

total_fails = 0
total = 0
boundsMinus = 0
boundsPlus = 0
success = []
fail = []
init_succ = 0
correct_succ1 = 0
correct_succ2 = 0
correct_succ3 = 0


# try to align the amplicons with the reference sequence at the position that
# was noted in the header
hits = [0]*5

for amplicon in amplicons:                           # for every amplicon in the list
    am_seq = amplicon['seq']
    corrections = [(-1, False), (0, True), (1, False), (((-1)*len(am_seq))+1, False), ((len(am_seq)), True)]
    if True:
        fails = 0
        #start_orig = start;
        matches = False
        i = 0
        while not matches and i < len(corrections):
            #tmp_seq = amplicon['seq']
            tmp_seq = am_seq
            if(corrections[i][1]):
                tmp_seq = reverseStrand(complementStrand(tmp_seq))
            start = amplicon['refstart'] + corrections[i][0]
            matches = match(tmp_seq, seq, start)
            i += 1

        i -= 1
        if matches:
            hits[i] = hits[i] + 1
            amplicon['offset']=i
            #amplicon['rc']=corrections[i][1]
            success.append(amplicon)
        else:
            fail.append(amplicon)
    total += 1

i = 0
print("\nSUCCESS:")
print(hits)

# analyse distribution of offsets over features like pos/neg strand, last on fragment etc.
success.sort(key=lambda x: (x['id']), reverse=False);

lastOnFragment_P = [0]*5
lastOnFragment_N = [0]*5
initiallyCorrect = 0
for amplicon in amplicons:

    successor = next((x for x in amplicons if x['id'] == amplicon['id']+1), None)
    if successor is None or successor['orig'] == amplicon['orig']+1:
        if(amplicon['strand'] == '+'):
            lastOnFragment_P[amplicon['offset']] += 1
        else:
            lastOnFragment_N[amplicon['offset']] += 1
    elif amplicon['offset'] == 1:
        initiallyCorrect += 1

print("Initially correct reverseStrand:" + str(initiallyCorrect))
print(lastOnFragment_P)
print(lastOnFragment_N)

print(len(success))
print("")


# try to align the amplicons with faulty reference positions brute force
found_fails = 0
for f in fail:
    foundMatches = findRealPosition(f['seq'], seq, f['refstart'], f['id'])
    found_fails += len(foundMatches)

print("> FAILS (no alignment possible): " + str(len(fail)-found_fails) + " of " + str(len(amplicons)))
